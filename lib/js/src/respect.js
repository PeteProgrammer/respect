// Generated by BUCKLESCRIPT VERSION 2.0.0, PLEASE EDIT WITH CARE
'use strict';

var List        = require("bs-platform/lib/js/list.js");
var Async       = require("re-sync/lib/js/src/Async.js");
var Block       = require("bs-platform/lib/js/block.js");
var Curry       = require("bs-platform/lib/js/curry.js");
var Pervasives  = require("bs-platform/lib/js/pervasives.js");
var TestContext = require("./TestContext.js");

var empty_004 = /* metadata */TestContext.ContextMap[/* empty */0];

var empty = /* record */[
  /* name */"",
  /* children : [] */0,
  /* setups : [] */0,
  /* examples : [] */0,
  empty_004
];

function addChild(child, root) {
  return /* record */[
          /* name */root[/* name */0],
          /* children */Pervasives.$at(root[/* children */1], /* :: */[
                child,
                /* [] */0
              ]),
          /* setups */root[/* setups */2],
          /* examples */root[/* examples */3],
          /* metadata */root[/* metadata */4]
        ];
}

function addExample(ex, grp) {
  return /* record */[
          /* name */grp[/* name */0],
          /* children */grp[/* children */1],
          /* setups */grp[/* setups */2],
          /* examples */Pervasives.$at(grp[/* examples */3], /* :: */[
                ex,
                /* [] */0
              ]),
          /* metadata */grp[/* metadata */4]
        ];
}

function addSetup(code, grp) {
  return /* record */[
          /* name */grp[/* name */0],
          /* children */grp[/* children */1],
          /* setups */Pervasives.$at(grp[/* setups */2], /* :: */[
                code,
                /* [] */0
              ]),
          /* examples */grp[/* examples */3],
          /* metadata */grp[/* metadata */4]
        ];
}

var ExampleGroup = /* module */[
  /* empty */empty,
  /* addChild */addChild,
  /* addExample */addExample,
  /* addSetup */addSetup
];

var Domain = /* module */[/* ExampleGroup */ExampleGroup];

function wrapTest(fn, ctx, callback) {
  try {
    Curry._1(fn, ctx);
    return Curry._1(callback, /* TestSucceeded */0);
  }
  catch (exn){
    return Curry._1(callback, /* TestFailed */1);
  }
}

function wrapW(fn, ctx, callback) {
  return Curry._2(fn, ctx, (function (err, _) {
                if (err) {
                  return Curry._1(callback, /* TestFailed */1);
                } else {
                  return Curry._1(callback, /* TestSucceeded */0);
                }
              }));
}

function it(name, ex) {
  return /* AddExampleOperation */Block.__(2, [
            name,
            (function (param, param$1) {
                return wrapTest(ex, param, param$1);
              })
          ]);
}

function it_a(name, ex) {
  return /* AddExampleOperation */Block.__(2, [
            name,
            ex
          ]);
}

function it_w(name, ex) {
  return /* AddExampleOperation */Block.__(2, [
            name,
            (function (param, param$1) {
                return wrapW(ex, param, param$1);
              })
          ]);
}

function describe(name, ops) {
  return /* AddChildGroupOperation */Block.__(1, [
            name,
            ops
          ]);
}

function beforeEach(fn) {
  return /* AddSetupOperation */Block.__(3, [(function (param, param$1) {
                return wrapTest(fn, param, param$1);
              })]);
}

function beforeEach_w(fn) {
  return /* AddSetupOperation */Block.__(3, [(function (param, param$1) {
                return wrapW(fn, param, param$1);
              })]);
}

function applyOperation(_operation, context, _metadata) {
  while(true) {
    var metadata = _metadata;
    var operation = _operation;
    switch (operation.tag | 0) {
      case 0 : 
          var match = operation[0];
          _metadata = Curry._3(TestContext.ContextMap[/* add */3], match[0], match[1], metadata);
          _operation = operation[1];
          continue ;
          case 1 : 
          var initial_000 = /* name */operation[0];
          var initial = /* record */[
            initial_000,
            /* children : [] */0,
            /* setups : [] */0,
            /* examples : [] */0,
            /* metadata */metadata
          ];
          var newChild = List.fold_left((function (grp, op) {
                  return applyOperation(op, grp, TestContext.ContextMap[/* empty */0]);
                }), initial, operation[1]);
          var newChild$prime_000 = /* name */newChild[/* name */0];
          var newChild$prime_001 = /* children */List.rev(newChild[/* children */1]);
          var newChild$prime_002 = /* setups */newChild[/* setups */2];
          var newChild$prime_003 = /* examples */List.rev(newChild[/* examples */3]);
          var newChild$prime_004 = /* metadata */newChild[/* metadata */4];
          var newChild$prime = /* record */[
            newChild$prime_000,
            newChild$prime_001,
            newChild$prime_002,
            newChild$prime_003,
            newChild$prime_004
          ];
          return /* record */[
                  /* name */context[/* name */0],
                  /* children : :: */[
                    newChild$prime,
                    context[/* children */1]
                  ],
                  /* setups */context[/* setups */2],
                  /* examples */context[/* examples */3],
                  /* metadata */context[/* metadata */4]
                ];
      case 2 : 
          return /* record */[
                  /* name */context[/* name */0],
                  /* children */context[/* children */1],
                  /* setups */context[/* setups */2],
                  /* examples : :: */[
                    /* record */[
                      /* name */operation[0],
                      /* func */operation[1],
                      /* metadata */metadata
                    ],
                    context[/* examples */3]
                  ],
                  /* metadata */context[/* metadata */4]
                ];
      case 3 : 
          return addSetup(/* Setup */[operation[0]], context);
      
    }
  };
}

function applyOperation$1(operation, context) {
  return applyOperation(operation, context, TestContext.ContextMap[/* empty */0]);
}

var rootContext = [empty];

function register(op) {
  rootContext[0] = applyOperation$1(op, rootContext[0]);
  return /* () */0;
}

function $star$star$great(param, op) {
  return /* WrapMetadata */Block.__(0, [
            /* tuple */[
              param[0],
              param[1]
            ],
            op
          ]);
}

var Async$1 = /* module */[
  /* **> */$star$star$great,
  /* it */it_w,
  /* describe */describe,
  /* register */register,
  /* beforeEach */beforeEach_w
];

var Dsl = /* module */[
  /* wrapTest */wrapTest,
  /* wrapW */wrapW,
  /* it */it,
  /* it_a */it_a,
  /* it_w */it_w,
  /* describe */describe,
  /* beforeEach */beforeEach,
  /* beforeEach_w */beforeEach_w,
  /* applyOperation */applyOperation$1,
  /* rootContext */rootContext,
  /* register */register,
  /* **> */$star$star$great,
  /* Async */Async$1
];

function mergeResult(a, b) {
  if (a !== 0 || b !== 0) {
    return /* TestFailed */1;
  } else {
    return /* TestSucceeded */0;
  }
}

function runExample(groupStack, ex, callback) {
  var mdStack = List.map((function (x) {
          return x[/* metadata */4];
        }), groupStack);
  var mdStack$prime_000 = ex[/* metadata */2];
  var mdStack$prime = /* :: */[
    mdStack$prime_000,
    mdStack
  ];
  var md = List.fold_left(TestContext.ContextMap[/* merge */23], TestContext.ContextMap[/* empty */0], mdStack$prime);
  var ctx = /* record */[/* data */md];
  var runParentGroups = function (grps) {
    if (grps) {
      var parents = grps[1];
      var runSetups = function (param) {
        if (param) {
          var rest = param[1];
          return Curry._2(param[0][0], ctx, (function (param) {
                        if (param !== 0) {
                          return Curry._1(callback, /* TestFailed */1);
                        } else {
                          return runSetups(rest);
                        }
                      }));
        } else {
          return runParentGroups(parents);
        }
      };
      return runSetups(grps[0][/* setups */2]);
    } else {
      return Curry._2(ex[/* func */1], ctx, (function (r) {
                    if (r === /* TestFailed */1) {
                      var groupNames = List.fold_left((function (acc, grp) {
                              if (grp[/* name */0] === "") {
                                return acc;
                              } else {
                                return grp[/* name */0] + " - " + acc;
                              }
                            }), "", groupStack);
                      console.log("EXAMPLE: " + groupNames + (ex[/* name */0] + " - FAILED"));
                    }
                    return Curry._1(callback, r);
                  }));
    }
  };
  return runParentGroups(List.rev(groupStack));
}

function run(grp, parents) {
  var groupStack = /* :: */[
    grp,
    parents
  ];
  var iter = function (state, tests) {
    if (tests) {
      var rest = tests[1];
      var ex = tests[0];
      return (function (param) {
          return Async.bind((function (result) {
                        return iter(mergeResult(result, state), rest);
                      }), (function (param) {
                        return Async.from_callback((function (param) {
                                      return runExample(groupStack, ex, param);
                                    }), param);
                      }), param);
        });
    } else {
      return (function (param) {
          return Async.$$return(state, param);
        });
    }
  };
  var iterGrps = function (state, grps) {
    if (grps) {
      var rest = grps[1];
      var partial_arg = run(grps[0], groupStack);
      return (function (param) {
          return Async.bind((function (result) {
                        return iterGrps(mergeResult(result, state), rest);
                      }), partial_arg, param);
        });
    } else {
      return (function (param) {
          return Async.$$return(state, param);
        });
    }
  };
  var partial_arg = iter(/* TestSucceeded */0, grp[/* examples */3]);
  return (function (param) {
      return Async.bind((function (exampleResults) {
                    return iterGrps(exampleResults, grp[/* children */1]);
                  }), partial_arg, param);
    });
}

function run$1(grp) {
  return run(grp, /* [] */0);
}

function runRoot() {
  return run(rootContext[0], /* [] */0);
}

var Runner = /* module */[
  /* mergeResult */mergeResult,
  /* runExample */runExample,
  /* run */run$1,
  /* runRoot */runRoot
];

function isSuccess(result) {
  if (result !== 0) {
    return /* false */0;
  } else {
    return /* true */1;
  }
}

var TestResult = /* module */[/* isSuccess */isSuccess];

var Matcher = 0;

var MatchersV2 = 0;

var Callbacks = 0;

var As = 0;

exports.Matcher    = Matcher;
exports.MatchersV2 = MatchersV2;
exports.Callbacks  = Callbacks;
exports.As         = As;
exports.Domain     = Domain;
exports.Dsl        = Dsl;
exports.Runner     = Runner;
exports.TestResult = TestResult;
/* TestContext Not a pure module */
