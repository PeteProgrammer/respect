// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
'use strict';

var List          = require("bs-platform/lib/js/list.js");
var Block         = require("bs-platform/lib/js/block.js");
var Curry         = require("bs-platform/lib/js/curry.js");
var Pervasives    = require("bs-platform/lib/js/pervasives.js");
var Respect_ctx   = require("./Respect_ctx.js");
var Respect_async = require("./Respect_async.js");

var empty_004 = /* metadata */Respect_ctx.ContextMap[/* empty */0];

var empty = /* record */[
  /* name */"",
  /* children : [] */0,
  /* setups : [] */0,
  /* examples : [] */0,
  empty_004
];

function addChild(child, root) {
  return /* record */[
          /* name */root[/* name */0],
          /* children */Pervasives.$at(root[/* children */1], /* :: */[
                child,
                /* [] */0
              ]),
          /* setups */root[/* setups */2],
          /* examples */root[/* examples */3],
          /* metadata */root[/* metadata */4]
        ];
}

function addExample(ex, grp) {
  return /* record */[
          /* name */grp[/* name */0],
          /* children */grp[/* children */1],
          /* setups */grp[/* setups */2],
          /* examples */Pervasives.$at(grp[/* examples */3], /* :: */[
                ex,
                /* [] */0
              ]),
          /* metadata */grp[/* metadata */4]
        ];
}

function addSetup(code, grp) {
  return /* record */[
          /* name */grp[/* name */0],
          /* children */grp[/* children */1],
          /* setups */Pervasives.$at(grp[/* setups */2], /* :: */[
                code,
                /* [] */0
              ]),
          /* examples */grp[/* examples */3],
          /* metadata */grp[/* metadata */4]
        ];
}

var ExampleGroup = /* module */[
  /* empty */empty,
  /* addChild */addChild,
  /* addExample */addExample,
  /* addSetup */addSetup
];

var Domain = /* module */[/* ExampleGroup */ExampleGroup];

function wrapTest(fn, ctx, callback) {
  try {
    Curry._1(fn, ctx);
    return Curry._1(callback, /* TestSucceeded */1);
  }
  catch (exn){
    return Curry._1(callback, /* TestFailed */2);
  }
}

function wrapW(fn, ctx, callback) {
  return Curry._2(fn, ctx, (function (err, _) {
                if (err) {
                  return Curry._1(callback, /* TestFailed */2);
                } else {
                  return Curry._1(callback, /* TestSucceeded */1);
                }
              }));
}

function it(name, ex) {
  return /* AddExampleOperation */Block.__(2, [
            name,
            (function (param, param$1) {
                return wrapTest(ex, param, param$1);
              })
          ]);
}

function it_a(name, ex) {
  return /* AddExampleOperation */Block.__(2, [
            name,
            ex
          ]);
}

function it_w(name, ex) {
  return /* AddExampleOperation */Block.__(2, [
            name,
            (function (param, param$1) {
                return wrapW(ex, param, param$1);
              })
          ]);
}

function describe(name, ops) {
  return /* AddChildGroupOperation */Block.__(1, [
            name,
            ops
          ]);
}

function beforeEach(fn) {
  return /* AddSetupOperation */Block.__(3, [(function (param, param$1) {
                return wrapTest(fn, param, param$1);
              })]);
}

function beforeEach_w(fn) {
  return /* AddSetupOperation */Block.__(3, [(function (param, param$1) {
                return wrapW(fn, param, param$1);
              })]);
}

function applyOperation(_operation, context, _metadata) {
  while(true) {
    var metadata = _metadata;
    var operation = _operation;
    switch (operation.tag | 0) {
      case 0 : 
          var match = operation[0];
          _metadata = Curry._3(Respect_ctx.ContextMap[/* add */3], match[0], match[1], metadata);
          _operation = operation[1];
          continue ;
          case 1 : 
          var initial_000 = /* name */operation[0];
          var initial = /* record */[
            initial_000,
            /* children : [] */0,
            /* setups : [] */0,
            /* examples : [] */0,
            /* metadata */metadata
          ];
          var newChild = List.fold_left((function (grp, op) {
                  return applyOperation(op, grp, Respect_ctx.ContextMap[/* empty */0]);
                }), initial, operation[1]);
          var newChild$prime_000 = /* name */newChild[/* name */0];
          var newChild$prime_001 = /* children */List.rev(newChild[/* children */1]);
          var newChild$prime_002 = /* setups */newChild[/* setups */2];
          var newChild$prime_003 = /* examples */List.rev(newChild[/* examples */3]);
          var newChild$prime_004 = /* metadata */newChild[/* metadata */4];
          var newChild$prime = /* record */[
            newChild$prime_000,
            newChild$prime_001,
            newChild$prime_002,
            newChild$prime_003,
            newChild$prime_004
          ];
          return /* record */[
                  /* name */context[/* name */0],
                  /* children : :: */[
                    newChild$prime,
                    context[/* children */1]
                  ],
                  /* setups */context[/* setups */2],
                  /* examples */context[/* examples */3],
                  /* metadata */context[/* metadata */4]
                ];
      case 2 : 
          return /* record */[
                  /* name */context[/* name */0],
                  /* children */context[/* children */1],
                  /* setups */context[/* setups */2],
                  /* examples : :: */[
                    /* record */[
                      /* name */operation[0],
                      /* func */operation[1],
                      /* metadata */metadata
                    ],
                    context[/* examples */3]
                  ],
                  /* metadata */context[/* metadata */4]
                ];
      case 3 : 
          return addSetup(/* Setup */[operation[0]], context);
      
    }
  };
}

function applyOperation$1(operation, context) {
  return applyOperation(operation, context, Respect_ctx.ContextMap[/* empty */0]);
}

var rootContext = [empty];

function register(op) {
  rootContext[0] = applyOperation$1(op, rootContext[0]);
  return /* () */0;
}

function $star$star$great(param, op) {
  return /* WrapMetadata */Block.__(0, [
            /* tuple */[
              param[0],
              param[1]
            ],
            op
          ]);
}

function pending(name) {
  return /* AddExampleOperation */Block.__(2, [
            name,
            (function (_, cb) {
                return Curry._1(cb, /* TestPending */0);
              })
          ]);
}

var Async = /* module */[
  /* **> */$star$star$great,
  /* it */it_w,
  /* describe */describe,
  /* register */register,
  /* beforeEach */beforeEach_w,
  /* pending */pending
];

var Dsl = /* module */[
  /* wrapTest */wrapTest,
  /* wrapW */wrapW,
  /* it */it,
  /* it_a */it_a,
  /* it_w */it_w,
  /* describe */describe,
  /* beforeEach */beforeEach,
  /* beforeEach_w */beforeEach_w,
  /* applyOperation */applyOperation$1,
  /* rootContext */rootContext,
  /* register */register,
  /* **> */$star$star$great,
  /* Async */Async
];

function mergeResult(a, b) {
  var exit = 0;
  switch (a) {
    case 0 : 
        exit = 1;
        break;
    case 1 : 
        if (b !== 1) {
          exit = 1;
        } else {
          return /* TestSucceeded */1;
        }
        break;
    case 2 : 
        return /* TestFailed */2;
    
  }
  if (exit === 1) {
    switch (b) {
      case 0 : 
      case 1 : 
          return /* TestPending */0;
      case 2 : 
          return /* TestFailed */2;
      
    }
  }
  
}

var empty$1 = /* record */[
  /* noOfPassed */0,
  /* noOfPending */0,
  /* noOfFailed */0
];

function recordResult(result, carry) {
  switch (result) {
    case 0 : 
        return /* record */[
                /* noOfPassed */carry[/* noOfPassed */0],
                /* noOfPending */carry[/* noOfPending */1] + 1 | 0,
                /* noOfFailed */carry[/* noOfFailed */2]
              ];
    case 1 : 
        return /* record */[
                /* noOfPassed */carry[/* noOfPassed */0] + 1 | 0,
                /* noOfPending */carry[/* noOfPending */1],
                /* noOfFailed */carry[/* noOfFailed */2]
              ];
    case 2 : 
        return /* record */[
                /* noOfPassed */carry[/* noOfPassed */0],
                /* noOfPending */carry[/* noOfPending */1],
                /* noOfFailed */carry[/* noOfFailed */2] + 1 | 0
              ];
    
  }
}

function merge(a, b) {
  return /* record */[
          /* noOfPassed */a[/* noOfPassed */0] + b[/* noOfPassed */0] | 0,
          /* noOfPending */a[/* noOfPending */1] + b[/* noOfPending */1] | 0,
          /* noOfFailed */a[/* noOfFailed */2] + b[/* noOfFailed */2] | 0
        ];
}

function getNoOfPassedTests(x) {
  return x[/* noOfPassed */0];
}

function getNoOfPendingTests(x) {
  return x[/* noOfPending */1];
}

function getNoOfFailedTests(x) {
  return x[/* noOfFailed */2];
}

function getResult(x) {
  var match = +(x[/* noOfFailed */2] > 0);
  if (match !== 0) {
    return /* TestFailed */2;
  } else {
    var match$1 = +(x[/* noOfPending */1] > 0);
    if (match$1 !== 0) {
      return /* TestPending */0;
    } else {
      return /* TestSucceeded */1;
    }
  }
}

var RunResult = /* module */[
  /* empty */empty$1,
  /* recordResult */recordResult,
  /* merge */merge,
  /* getNoOfPassedTests */getNoOfPassedTests,
  /* getNoOfPendingTests */getNoOfPendingTests,
  /* getNoOfFailedTests */getNoOfFailedTests,
  /* getResult */getResult
];

function runExample(groupStack, ex) {
  var mdStack = List.map((function (x) {
          return x[/* metadata */4];
        }), groupStack);
  var mdStack$prime_000 = ex[/* metadata */2];
  var mdStack$prime = /* :: */[
    mdStack$prime_000,
    mdStack
  ];
  var md = List.fold_left(Respect_ctx.ContextMap[/* merge */23], Respect_ctx.ContextMap[/* empty */0], mdStack$prime);
  var ctx = Respect_ctx.create(md);
  var logError = function (r) {
    if (!r) {
      var groupNames = List.fold_left((function (acc, grp) {
              if (grp[/* name */0] === "") {
                return acc;
              } else {
                return grp[/* name */0] + (" - " + acc);
              }
            }), "", groupStack);
      console.log("EXAMPLE: " + (groupNames + (ex[/* name */0] + " - PENDING")));
    }
    if (r === /* TestFailed */2) {
      var groupNames$1 = List.fold_left((function (acc, grp) {
              if (grp[/* name */0] === "") {
                return acc;
              } else {
                return grp[/* name */0] + (" - " + acc);
              }
            }), "", groupStack);
      console.log("EXAMPLE: " + (groupNames$1 + (ex[/* name */0] + " - FAILED")));
    }
    return r;
  };
  var runParentGroups = function (grps) {
    if (grps) {
      var parents = grps[1];
      var runSetups = function (setups) {
        if (setups) {
          var rest = setups[1];
          var partial_arg = Curry._1(setups[0][0], ctx);
          var partial_arg$1 = function (param) {
            return Respect_async.from_callback(partial_arg, param);
          };
          return (function (param) {
              return Respect_async.bind((function (param) {
                            switch (param) {
                              case 0 : 
                                  return (function (param) {
                                      return Respect_async.$$return(/* TestPending */0, param);
                                    });
                              case 1 : 
                                  return runSetups(rest);
                              case 2 : 
                                  return (function (param) {
                                      return Respect_async.$$return(/* TestFailed */2, param);
                                    });
                              
                            }
                          }), partial_arg$1, param);
            });
        } else {
          return runParentGroups(parents);
        }
      };
      return runSetups(grps[0][/* setups */2]);
    } else {
      var partial_arg = Curry._1(ex[/* func */1], ctx);
      return (function (param) {
          return Respect_async.from_callback(partial_arg, param);
        });
    }
  };
  var partial_arg = Respect_async.timeout(/* Seconds */Block.__(1, [1]), runParentGroups(List.rev(groupStack)));
  var partial_arg$1 = function (param) {
    return Respect_async.tryCatch((function () {
                  return /* Some */[/* TestFailed */2];
                }), partial_arg, param);
  };
  return (function (param) {
      return Respect_async.map(logError, partial_arg$1, param);
    });
}

function run(grp, parents) {
  var groupStack = /* :: */[
    grp,
    parents
  ];
  var iter = function (state, tests) {
    if (tests) {
      var rest = tests[1];
      return Respect_async.Infix[/* >>= */0](runExample(groupStack, tests[0]), (function (result) {
                    return iter(recordResult(result, state), rest);
                  }));
    } else {
      return (function (param) {
          return Respect_async.$$return(state, param);
        });
    }
  };
  var iterGrps = function (state, grps) {
    if (grps) {
      var rest = grps[1];
      return Respect_async.Infix[/* >>= */0](run(grps[0], groupStack), (function (result) {
                    return iterGrps(merge(result, state), rest);
                  }));
    } else {
      return (function (param) {
          return Respect_async.$$return(state, param);
        });
    }
  };
  return Respect_async.Infix[/* >>= */0](iter(empty$1, grp[/* examples */3]), (function (exampleResults) {
                return iterGrps(exampleResults, grp[/* children */1]);
              }));
}

function run$1(grp) {
  return run(grp, /* [] */0);
}

function runRoot() {
  return run(rootContext[0], /* [] */0);
}

var Runner = /* module */[
  /* mergeResult */mergeResult,
  /* RunResult */RunResult,
  /* runExample */runExample,
  /* run */run$1,
  /* runRoot */runRoot
];

function isSuccess(result) {
  var match = +(result[/* noOfFailed */2] > 0);
  if (match !== 0) {
    return /* false */0;
  } else {
    return /* true */1;
  }
}

var TestResult = /* module */[/* isSuccess */isSuccess];

var Matcher = 0;

var MatchersV2 = 0;

var Callbacks = 0;

var As = 0;

var Ctx = 0;

exports.Matcher    = Matcher;
exports.MatchersV2 = MatchersV2;
exports.Callbacks  = Callbacks;
exports.As         = As;
exports.Ctx        = Ctx;
exports.Domain     = Domain;
exports.Dsl        = Dsl;
exports.Runner     = Runner;
exports.TestResult = TestResult;
/* Respect_ctx Not a pure module */
