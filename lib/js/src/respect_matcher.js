// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
'use strict';

var Block           = require("bs-platform/lib/js/block.js");
var Curry           = require("bs-platform/lib/js/curry.js");
var Caml_obj        = require("bs-platform/lib/js/caml_obj.js");
var Pervasives      = require("bs-platform/lib/js/pervasives.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");

var MatchFailedException = Caml_exceptions.create("Respect_matcher.MatchFailedException");

function $great$eq$great(a, b, x, cb) {
  return Curry._2(a, x, (function (param) {
                if (param.tag) {
                  return Curry._1(cb, /* MatchFailure */Block.__(1, [
                                param[0],
                                param[1]
                              ]));
                } else {
                  return Curry._2(b, param[0], cb);
                }
              }));
}

function matchSuccess(a, cb) {
  return Curry._1(cb, /* MatchSuccess */Block.__(0, [a]));
}

function matchFailure(actual, exp, cb) {
  return Curry._1(cb, /* MatchFailure */Block.__(1, [
                actual,
                exp
              ]));
}

function equal(expected, actual) {
  var match = Caml_obj.caml_equal(actual, expected);
  if (match !== 0) {
    return (function (param) {
        return Curry._1(param, /* MatchSuccess */Block.__(0, [actual]));
      });
  } else {
    return (function (param) {
        return Curry._1(param, /* MatchFailure */Block.__(1, [
                      actual,
                      expected
                    ]));
      });
  }
}

function beGreaterThan(expected, actual) {
  var match = Caml_obj.caml_greaterthan(actual, expected);
  if (match !== 0) {
    return (function (param) {
        return Curry._1(param, /* MatchSuccess */Block.__(0, [actual]));
      });
  } else {
    return (function (param) {
        return Curry._1(param, /* MatchFailure */Block.__(1, [
                      actual,
                      expected
                    ]));
      });
  }
}

function beLessThan(expected, actual) {
  var match = Caml_obj.caml_lessthan(actual, expected);
  if (match !== 0) {
    return (function (param) {
        return Curry._1(param, /* MatchSuccess */Block.__(0, [actual]));
      });
  } else {
    return (function (param) {
        return Curry._1(param, /* MatchFailure */Block.__(1, [
                      actual,
                      expected
                    ]));
      });
  }
}

function should(matcher, actual) {
  var result = [/* None */0];
  Curry._2(matcher, actual, (function (r) {
          result[0] = /* Some */[r];
          return /* () */0;
        }));
  var match = result[0];
  if (match) {
    var match$1 = match[0];
    if (match$1.tag) {
      console.log("Match failed");
      console.log("Expected: ", match$1[1]);
      console.log("Actual: ", match$1[0]);
      throw [
            MatchFailedException,
            "Match failed"
          ];
    } else {
      return /* () */0;
    }
  } else {
    return Pervasives.failwith("Matcher did not eval synchronously");
  }
}

function shoulda(matcher, actual, don) {
  var handleMatch = function (result) {
    if (result.tag) {
      console.log("Match failed");
      console.log(/* tuple */[
            "Expected: ",
            result[1]
          ]);
      console.log(/* tuple */[
            "Actual: ",
            result[0]
          ]);
      return Curry._2(don, /* Some */["match failed"], /* () */0);
    } else {
      return Curry._2(don, /* None */0, /* () */0);
    }
  };
  return Curry._2(matcher, actual, handleMatch);
}

exports.MatchFailedException = MatchFailedException;
exports.$great$eq$great      = $great$eq$great;
exports.matchSuccess         = matchSuccess;
exports.matchFailure         = matchFailure;
exports.equal                = equal;
exports.beGreaterThan        = beGreaterThan;
exports.beLessThan           = beLessThan;
exports.should               = should;
exports.shoulda              = shoulda;
/* No side effect */
