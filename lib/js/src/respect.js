// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
'use strict';

var List        = require("bs-platform/lib/js/list.js");
var Async       = require("@stroiman/async/lib/js/src/Async.js");
var Block       = require("bs-platform/lib/js/block.js");
var Curry       = require("bs-platform/lib/js/curry.js");
var Respect_ctx = require("./Respect_ctx.js");
var Respect_dsl = require("./Respect_dsl.js");

function $great$great$eq(x, f) {
  return (function (param) {
      return Async.bind(f, x, param);
    });
}

var AsyncInfix = /* module */[/* >>= */$great$great$eq];

function mergeResult(a, b) {
  var exit = 0;
  switch (a) {
    case 0 : 
        exit = 1;
        break;
    case 1 : 
        if (b !== 1) {
          exit = 1;
        } else {
          return /* TestSucceeded */1;
        }
        break;
    case 2 : 
        return /* TestFailed */2;
    
  }
  if (exit === 1) {
    switch (b) {
      case 0 : 
      case 1 : 
          return /* TestPending */0;
      case 2 : 
          return /* TestFailed */2;
      
    }
  }
  
}

var empty = /* record */[
  /* noOfPassed */0,
  /* noOfPending */0,
  /* noOfFailed */0
];

function recordResult(result, carry) {
  switch (result) {
    case 0 : 
        return /* record */[
                /* noOfPassed */carry[/* noOfPassed */0],
                /* noOfPending */carry[/* noOfPending */1] + 1 | 0,
                /* noOfFailed */carry[/* noOfFailed */2]
              ];
    case 1 : 
        return /* record */[
                /* noOfPassed */carry[/* noOfPassed */0] + 1 | 0,
                /* noOfPending */carry[/* noOfPending */1],
                /* noOfFailed */carry[/* noOfFailed */2]
              ];
    case 2 : 
        return /* record */[
                /* noOfPassed */carry[/* noOfPassed */0],
                /* noOfPending */carry[/* noOfPending */1],
                /* noOfFailed */carry[/* noOfFailed */2] + 1 | 0
              ];
    
  }
}

function merge(a, b) {
  return /* record */[
          /* noOfPassed */a[/* noOfPassed */0] + b[/* noOfPassed */0] | 0,
          /* noOfPending */a[/* noOfPending */1] + b[/* noOfPending */1] | 0,
          /* noOfFailed */a[/* noOfFailed */2] + b[/* noOfFailed */2] | 0
        ];
}

function getNoOfPassedTests(x) {
  return x[/* noOfPassed */0];
}

function getNoOfPendingTests(x) {
  return x[/* noOfPending */1];
}

function getNoOfFailedTests(x) {
  return x[/* noOfFailed */2];
}

function getResult(x) {
  var match = +(x[/* noOfFailed */2] > 0);
  if (match !== 0) {
    return /* TestFailed */2;
  } else {
    var match$1 = +(x[/* noOfPending */1] > 0);
    if (match$1 !== 0) {
      return /* TestPending */0;
    } else {
      return /* TestSucceeded */1;
    }
  }
}

var RunResult = /* module */[
  /* empty */empty,
  /* recordResult */recordResult,
  /* merge */merge,
  /* getNoOfPassedTests */getNoOfPassedTests,
  /* getNoOfPendingTests */getNoOfPendingTests,
  /* getNoOfFailedTests */getNoOfFailedTests,
  /* getResult */getResult
];

function runExample(groupStack, ex) {
  var mdStack = List.map((function (x) {
          return x[/* metadata */4];
        }), groupStack);
  var mdStack$prime_000 = ex[/* metadata */2];
  var mdStack$prime = /* :: */[
    mdStack$prime_000,
    mdStack
  ];
  var md = List.fold_left(Respect_ctx.ContextMap[/* merge */23], Respect_ctx.ContextMap[/* empty */0], mdStack$prime);
  var ctx = Respect_ctx.create(md);
  var logError = function (r) {
    if (!r) {
      var groupNames = List.fold_left((function (acc, grp) {
              if (grp[/* name */0] === "") {
                return acc;
              } else {
                return grp[/* name */0] + (" - " + acc);
              }
            }), "", groupStack);
      console.log("EXAMPLE: " + (groupNames + (ex[/* name */0] + " - PENDING")));
    }
    if (r === /* TestFailed */2) {
      var groupNames$1 = List.fold_left((function (acc, grp) {
              if (grp[/* name */0] === "") {
                return acc;
              } else {
                return grp[/* name */0] + (" - " + acc);
              }
            }), "", groupStack);
      console.log("EXAMPLE: " + (groupNames$1 + (ex[/* name */0] + " - FAILED")));
    }
    return r;
  };
  var runParentGroups = function (grps) {
    if (grps) {
      var parents = grps[1];
      var runSetups = function (setups) {
        if (setups) {
          var rest = setups[1];
          var partial_arg = Curry._1(setups[0][0], ctx);
          var partial_arg$1 = function (param) {
            return Async.from_callback(partial_arg, param);
          };
          return (function (param) {
              return Async.bind((function (param) {
                            switch (param) {
                              case 0 : 
                                  return (function (param) {
                                      return Async.$$return(/* TestPending */0, param);
                                    });
                              case 1 : 
                                  return runSetups(rest);
                              case 2 : 
                                  return (function (param) {
                                      return Async.$$return(/* TestFailed */2, param);
                                    });
                              
                            }
                          }), partial_arg$1, param);
            });
        } else {
          return runParentGroups(parents);
        }
      };
      return runSetups(grps[0][/* setups */2]);
    } else {
      var partial_arg = Curry._1(ex[/* func */1], ctx);
      return (function (param) {
          return Async.from_callback(partial_arg, param);
        });
    }
  };
  var partial_arg = Async.timeout(/* Seconds */Block.__(1, [1]), runParentGroups(List.rev(groupStack)));
  var partial_arg$1 = function (param) {
    return Async.tryCatch((function () {
                  return /* Some */[/* TestFailed */2];
                }), partial_arg, param);
  };
  return (function (param) {
      return Async.map(logError, partial_arg$1, param);
    });
}

function run(grp, parents) {
  var groupStack = /* :: */[
    grp,
    parents
  ];
  var iter = function (state, tests) {
    if (tests) {
      var rest = tests[1];
      var x = runExample(groupStack, tests[0]);
      return (function (param) {
          return Async.bind((function (result) {
                        return iter(recordResult(result, state), rest);
                      }), x, param);
        });
    } else {
      return (function (param) {
          return Async.$$return(state, param);
        });
    }
  };
  var iterGrps = function (state, grps) {
    if (grps) {
      var rest = grps[1];
      var x = run(grps[0], groupStack);
      return (function (param) {
          return Async.bind((function (result) {
                        return iterGrps(merge(result, state), rest);
                      }), x, param);
        });
    } else {
      return (function (param) {
          return Async.$$return(state, param);
        });
    }
  };
  var x = iter(empty, grp[/* examples */3]);
  return (function (param) {
      return Async.bind((function (exampleResults) {
                    return iterGrps(exampleResults, grp[/* children */1]);
                  }), x, param);
    });
}

function run$1(grp) {
  return run(grp, /* [] */0);
}

function runRoot() {
  return run(Respect_dsl.rootContext[0], /* [] */0);
}

var Runner = /* module */[
  /* mergeResult */mergeResult,
  /* RunResult */RunResult,
  /* runExample */runExample,
  /* run */run$1,
  /* runRoot */runRoot
];

function isSuccess(result) {
  var match = +(result[/* noOfFailed */2] > 0);
  if (match !== 0) {
    return /* false */0;
  } else {
    return /* true */1;
  }
}

var TestResult = /* module */[/* isSuccess */isSuccess];

var Matcher = 0;

var MatchersV2 = 0;

var Callbacks = 0;

var Ctx = 0;

var Domain = 0;

var Dsl = 0;

exports.Matcher    = Matcher;
exports.MatchersV2 = MatchersV2;
exports.Callbacks  = Callbacks;
exports.Ctx        = Ctx;
exports.Domain     = Domain;
exports.Dsl        = Dsl;
exports.AsyncInfix = AsyncInfix;
exports.Runner     = Runner;
exports.TestResult = TestResult;
/* Respect_ctx Not a pure module */
